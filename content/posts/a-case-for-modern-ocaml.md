---
title: A Case for Modern OCaml
date: '2021-02-18T09:52:01-06:00'
categories:
  - ''
tags:
  - OCaml programming
keywords:
  - OCaml programming
---
A topic that is often discussed when programmers get together is about programming language choice and the perceived benefits of said language. In recent memory, I've heard people discuss picking Go for static binaries, Rust for memory safety, or using new Python to get its types. It's often an immensely complicated choice with many factors influencing it but I'd like to layout some of the reasons that I think there is a compelling case for modern OCaml and why you might want to use it for your next project.

Most people who have had an academic computer science education have encountered OCaml before in a limited context. Often it's used to teach typed languages, compilers, or any other variety of CS concepts. Unfortunately this is often taught using an OCaml compiler and toolchain that is quite old and for lack of a better term, crusty. However the modern OCaml toolchain has seen a significant amount of work in recent years and is now on par or superior than most other language ecosystems. I'd encourage individuals to look past their previous experience and try out the modern language. 

The stars of the current OCaml tooling world are opam & dune. Opam is the language package manager. Besides the obvious feature of downloading, installing and managing packages, opam has the handy feature that it also manages compilers as well. This includes the ability to make a separate environment in any folder making it trivially easy to keep multiple projects with separate dependancies organized easily. It also includes the ability to symlink local installs which makes it easy to share the same compiler install between different code branches on the same machine.  Opam also includes support for locking dependancies to exact versions, making it easy to ensure that different installs of a project produce the exact same result. It also has support for pinning which allows you to override the install location of an upstream dependency in a single command which can be very handy for using a fork with a specific patch or bug-fix. 

Dune the build system for OCaml/Reason (a sister language of OCaml) is the other side of the OCaml tooling system. Dune allows you to write very simple s-expressions in a file and get consistent tooling for building, testing, and running that works well out of the box. One of the features that really shines in dune is the ability to have multiple executables and/or libraries all inside the same dune workspace (read: top level file folder). This means that inside that folder, you can move/rearrange where those compents are and dune will do all the hard work of linking them together and producing a build without making any changes to the dune file of any of the libraries or executables. In addition, it makes it easy to have internal libraries that are linked against a wide variety of other libraries or services. These two features make it very easy to manage large codebases in a single repository. Dune also allows for significant complexity, such as managing the process of linking against c libraries, as to be expected of a build tool but Dune is exceedingly well designed to only expose that complexity to the user when needed.

OCaml is a strongly typed language with support for product, sum types as an example. This often carries significant connotations but it is one of the strongest points of the language. One aspect of computer systems that is often fraught with difficulty is the interfaces between different pieces of the codebase. A good type system and design will help you mitigate some of that difficulty by allowing the computer to check some aspects and explain if something is does not match it's expected result. Rather than viewing this ability as a draconian restriction of freedom, this ability is in fact freeing the program author from significant mental fatigue. The ability to designate some level of checking to a compiler allows the author to focus on the high level logic of what is happening rather than worry about data validation/interface concerns. 

This type system and its associated assistance really starts to shiny in the maintenance of large code bases. Refactoring has traditionally been one of the most tedious, monotonous tasks, and failure prone tasks. Entire books have been written about the subject and as it turns out a type system will not solve the problem entirely but it does gives two significant ability within the context of refactoring. The first is is the joy of changing a function signature/type and allowing the compiler to find all locations that are broken. Rather than relying on search tools that have a superficial level of understanding of the language, allowing the language itself guide us to sections of code that need to be changed is much more reliable. The second aspect is the ability to have confidence in the output after a refactor given a well designed typed application. Because the compiler can check on the interfaces between sections of the codebase, the author can have confidence in the refactored codebase as a whole. 

One of the unsung benefits of having a garbage collector in a language is the ability to avoid certain classes of vulnerabilities around memory safety. This issue has been coming up more and more as various projects are trying to avoid the security implications around the historic methods of manually managing memory. It's important to note that OCaml remains quite performant even with this garbage collection. OCaml also does retain the ability to link in c/c++ programs via FFI, so it is possible to still have security issues depending on what libraries you use and how they are implemented. Still there are increasingly more libraries implemented in pure OCaml due to mirage libraries needing to be pure OCaml as well as the security benefits that said libraries provide. One particularly notable example worth calling out are the [tls library](https://github.com/mirleft/ocaml-tls) which was tested via being used to implement and secure a [bitcoin pinata](https://hannes.nqsb.io/Posts/Pinata) for several years.

Recently there has been a focus on in the OCaml community on tooling. Although tools like [merlin](https://github.com/ocaml/merlin) have existed for quite sometime, there has been a great deal of effort put into [ocaml-lsp](https://github.com/ocaml/ocaml-lsp) which uses merlin under the hood but provides the language server protocol. One of my favorite features about the language tooling is being able to ask my editor what type a variable is. If bound to a quick keybind, this often results in subsecond feedback loop to ask questions about a variables type and check if my program is doing the correct thing. The other time that I find this tooling immensively useful is the ability to ask about variables types when reviewing new code. Combined with the ability to quickly go to a correct definition for a function, this tooling reduces the time needed to understand a chunk of code when reviewing. 

OCaml has been around for a significant amount of time and has been the subject of academic attention for some time. There are some particularly interesting libraries that deserve a mention because of the interesting things that you can do easily.

MirageOS is more than a library, it's a set of tools/libraries that allow you to make OCaml unikernels that contain only the application code. This tiny operating system can then be deployed on either xen or kvm as a guest virtual machine. The sky is the limit on what these operating systems can do. The earlier bitcoin pinata was deployed via a MirageOS unikernel. Two other notable examples are a [hsm from Nitrokey](https://www.nitrokey.com/products/nethsm) in which the software is using MirageOS, and a [unikernel firewall](http://roscidus.com/blog/blog/2016/01/01/a-unikernel-firewall-for-qubesos/) that the Qubes project uses for intra vm traffic. 

Analysis of program binaries is a difficult task that has been the subject of research. Binary Analysis Platform (Bap) from CMU is a toolkit that is written primarily in OCaml that allows among other things custom binary analysis passes to be written. One of the most interesting competitions in helld recently in computer security was the Cyber Grand Challenge which was won by ForAllSecure which used Bap. 

It's almost a meme to say that OCaml's most common usage is writing compilers for other languages but [Menhir](http://gallium.inria.fr/~fpottier/menhir/) is a tool that does exactly that. Menhir takes a LR(1) grammer and produces code for an OCaml parser for that grammer. This can be as simple as a tiny calc language that you want to embed or as complicated as a whole programming language. This ability along with the robust type system gives rise to the ability to write powerful domain specific languages that are customized to the problem space. It should be noted that dune has [built in menhir support](https://dune.readthedocs.io/en/stable/dune-files.html#menhir). 

None of the above is to say that learning OCaml is easy, although it's well worth the effort. There are excellent books like [Real World OCaml](https://dev.realworldocaml.org) which are so comprehensive it would be suprising if even an experienced OCaml developer didn't learn something reading though.  OCaml's community is also a joy to interact with, the forums that are interesting to read, and the inhabitents of the public chat channels are pleasant and helpful. 

Language choice is complex with no single aspect even coming close to covering why an individual may choose a given language for a project. Despite that, OCaml has a lot to offer as a modern programming language, it's a language that is type safe, it's a language that can be memory safe, it's a language with good development tooling but probably most importantly, it's a language that is enjoyable to use while solving problems. So if any of this has sounded appealing to you, hopefully you'll give OCaml a whirl next time you want to check out a new language.
